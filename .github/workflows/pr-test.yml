---
name: Test

# Use workflow-wide concurrency (not per-branch) to prevent race conditions
# on shared CloudFormation test stacks. Multiple PRs will queue sequentially.
concurrency:
  group: pr-test
  cancel-in-progress: false # Ensure cleanup always runs

on:
  pull_request:
    branches:
      - main

env:
  CARGO_TERM_COLOR: always

jobs:
  changes:
    runs-on: ubuntu-latest
    outputs:
      src: ${{ steps.changes.outputs.src }}
    steps:
      - uses: actions/checkout@v6
      - uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            src:
              - src/**
              - test/**
              - Cargo.toml
              - Cargo.lock
              - .github/workflows/pr-test.yml

  # Build Rust binary (lint, test, build)
  build:
    needs: changes
    if: needs.changes.outputs.src == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: Update local toolchain
        run: rustup update

      - name: Install stable toolchain
        run: |
          rustup install stable
          rustup default stable

      - name: Install clippy
        run: rustup component add clippy

      - name: Toolchain info
        run: |
          cargo --version --verbose
          rustc --version
          cargo clippy --version

      - name: Rust dependency cache
        uses: actions/cache@v5
        with:
          path: target
          key: ${{ runner.os }}-stable-target-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-stable-target-

      - name: Lint
        run: |
          cargo fmt -- --check
          cargo clippy -- -D warnings

      - name: Test
        run: |
          cargo check
          cargo test --all

      - name: Build binary
        run: cargo install --path .

      - name: Upload binary artifact
        uses: actions/upload-artifact@v7
        with:
          name: cfn-teleport-binary
          path: ~/.cargo/bin/cfn-teleport
          retention-days: 1

  # Build Windows binary and validate embedded metadata
  build-windows:
    needs: changes
    if: needs.changes.outputs.src == 'true'
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: Update local toolchain
        run: rustup update

      - name: Install stable toolchain
        run: |
          rustup install stable
          rustup default stable

      - name: Toolchain info
        run: |
          cargo --version --verbose
          rustc --version

      - name: Rust dependency cache
        uses: actions/cache@v5
        with:
          path: target
          key: ${{ runner.os }}-stable-target-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-stable-target-

      - name: Build Windows binary
        run: cargo build --release

      - name: Validate Windows executable metadata
        shell: pwsh
        run: |
          Write-Host "=========================================="
          Write-Host "Validating Windows Executable Metadata"
          Write-Host "=========================================="
          Write-Host ""

          # Parse expected version from Cargo.toml
          $cargoToml = Get-Content "Cargo.toml" -Raw
          if ($cargoToml -match 'version\s*=\s*"([^"]+)"') {
              $expectedVersion = $matches[1]
              Write-Host "Expected version from Cargo.toml: $expectedVersion"
          } else {
              Write-Host "ERROR: Could not parse version from Cargo.toml"
              exit 1
          }

          # Parse expected description from Cargo.toml
          if ($cargoToml -match 'description\s*=\s*"([^"]+)"') {
              $expectedDescription = $matches[1]
              Write-Host "Expected description from Cargo.toml: $expectedDescription"
          } else {
              Write-Host "ERROR: Could not parse description from Cargo.toml"
              exit 1
          }

          # Parse expected authors from Cargo.toml
          if ($cargoToml -match 'authors\s*=\s*\[([^\]]+)\]') {
              $authorsMatch = $matches[1]
              # Extract first author (remove quotes and whitespace)
              if ($authorsMatch -match '"([^"]+)"') {
                  $expectedCompany = $matches[1]
                  Write-Host "Expected company name from Cargo.toml: $expectedCompany"
              } else {
                  Write-Host "ERROR: Could not parse authors from Cargo.toml"
                  exit 1
              }
          } else {
              Write-Host "ERROR: Could not find authors in Cargo.toml"
              exit 1
          }

          # Parse expected license from Cargo.toml
          if ($cargoToml -match 'license\s*=\s*"([^"]+)"') {
              $expectedLicense = $matches[1]
              Write-Host "Expected license from Cargo.toml: $expectedLicense"
          } else {
              Write-Host "ERROR: Could not parse license from Cargo.toml"
              exit 1
          }

          # Construct expected copyright string
          $expectedCopyright = "Copyright © $expectedCompany. Licensed under $expectedLicense"
          Write-Host "Expected copyright: $expectedCopyright"
          Write-Host ""

          # Read metadata from the compiled .exe
          $exePath = "target\release\cfn-teleport.exe"
          if (-not (Test-Path $exePath)) {
              Write-Host "ERROR: Binary not found at $exePath"
              exit 1
          }

          Write-Host "Reading metadata from: $exePath"
          $versionInfo = (Get-Item $exePath).VersionInfo

          # Validate all metadata fields
          $allValid = $true

          # 1. FileVersion
          if ($versionInfo.FileVersion -ne $expectedVersion) {
              Write-Host "❌ FileVersion mismatch: expected '$expectedVersion', got '$($versionInfo.FileVersion)'"
              $allValid = $false
          } else {
              Write-Host "✅ FileVersion: $($versionInfo.FileVersion)"
          }

          # 2. ProductVersion
          if ($versionInfo.ProductVersion -ne $expectedVersion) {
              Write-Host "❌ ProductVersion mismatch: expected '$expectedVersion', got '$($versionInfo.ProductVersion)'"
              $allValid = $false
          } else {
              Write-Host "✅ ProductVersion: $($versionInfo.ProductVersion)"
          }

          # 3. FileDescription
          if ($versionInfo.FileDescription -ne $expectedDescription) {
              Write-Host "❌ FileDescription mismatch: expected '$expectedDescription', got '$($versionInfo.FileDescription)'"
              $allValid = $false
          } else {
              Write-Host "✅ FileDescription: $($versionInfo.FileDescription)"
          }

          # 4. ProductName
          if ($versionInfo.ProductName -ne "cfn-teleport") {
              Write-Host "❌ ProductName mismatch: expected 'cfn-teleport', got '$($versionInfo.ProductName)'"
              $allValid = $false
          } else {
              Write-Host "✅ ProductName: $($versionInfo.ProductName)"
          }

          # 5. CompanyName
          if ($versionInfo.CompanyName -ne $expectedCompany) {
              Write-Host "❌ CompanyName mismatch: expected '$expectedCompany', got '$($versionInfo.CompanyName)'"
              $allValid = $false
          } else {
              Write-Host "✅ CompanyName: $($versionInfo.CompanyName)"
          }

          # 6. LegalCopyright
          if ($versionInfo.LegalCopyright -ne $expectedCopyright) {
              Write-Host "❌ LegalCopyright mismatch: expected '$expectedCopyright', got '$($versionInfo.LegalCopyright)'"
              $allValid = $false
          } else {
              Write-Host "✅ LegalCopyright: $($versionInfo.LegalCopyright)"
          }

          # 7. OriginalFilename
          if ($versionInfo.OriginalFilename -ne "cfn-teleport.exe") {
              Write-Host "❌ OriginalFilename mismatch: expected 'cfn-teleport.exe', got '$($versionInfo.OriginalFilename)'"
              $allValid = $false
          } else {
              Write-Host "✅ OriginalFilename: $($versionInfo.OriginalFilename)"
          }

          Write-Host ""
          if ($allValid) {
              Write-Host "=========================================="
              Write-Host "✅ All metadata fields validated successfully!"
              Write-Host "=========================================="
              exit 0
          } else {
              Write-Host "=========================================="
              Write-Host "❌ Metadata validation failed!"
              Write-Host "=========================================="
              exit 1
          }

      - name: Upload Windows binary artifact
        uses: actions/upload-artifact@v7
        with:
          name: cfn-teleport-windows-binary
          path: target/release/cfn-teleport.exe
          retention-days: 1

  # Deploy test stacks in parallel (matrix strategy for speed)
  prepare-stacks:
    needs: changes
    if: needs.changes.outputs.src == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        template:
          - CfnTeleportRefactorTest1.json
          - CfnTeleportRefactorTest2.yaml
          - CfnTeleportImportTest1.json
          - CfnTeleportImportTest2.yaml
          - CfnTeleportRenameTest1.json
          - CfnTeleportWindowsTest1.json
          - CfnTeleportWindowsTest2.yaml
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Deploy stack
        working-directory: test/cloudformation
        env:
          AWS_DEFAULT_REGION: us-east-1
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          # Extract stack name from template filename (remove extension)
          STACK_NAME="${{ matrix.template }}"
          STACK_NAME="${STACK_NAME%.json}"
          STACK_NAME="${STACK_NAME%.yaml}"

          # Build parameter overrides based on stack
          PARAMS=""
          CAPABILITIES=""

          # RefactorTest1 uses parameters and requires IAM capability
          if [ "$STACK_NAME" = "CfnTeleportRefactorTest1" ]; then
            PARAMS="--parameter-overrides ParameterTableName=cfn-teleport-refactor-param-test"
            CAPABILITIES="--capabilities CAPABILITY_NAMED_IAM"
          fi

          # RefactorTest2 uses same parameters as RefactorTest1
          if [ "$STACK_NAME" = "CfnTeleportRefactorTest2" ]; then
            PARAMS="--parameter-overrides ParameterTableName=cfn-teleport-refactor-param-test"
          fi

          # RenameTest1 requires IAM capability and QueueName parameter
          if [ "$STACK_NAME" = "CfnTeleportRenameTest1" ]; then
            CAPABILITIES="--capabilities CAPABILITY_NAMED_IAM"
            PARAMS="--parameter-overrides QueueName=cfn-teleport-rename-test-queue"
          fi

          # ImportTest1 and ImportTest2 have no parameters (import mode compatible)

          aws cloudformation deploy \
            --template-file ${{ matrix.template }} \
            --stack-name "$STACK_NAME" \
            $CAPABILITIES \
            $PARAMS \
            --tags ApplicationName=cfn-teleport-test \
            --no-fail-on-empty-changeset

  # Refactor mode tests (runs in parallel with import and rename tests)
  test-refactor:
    needs:
      - build
      - prepare-stacks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download binary artifact
        uses: actions/download-artifact@v8
        with:
          name: cfn-teleport-binary
          path: /tmp/cfn-teleport-bin

      - name: Install binary
        run: |
          chmod +x /tmp/cfn-teleport-bin/cfn-teleport
          sudo mv /tmp/cfn-teleport-bin/cfn-teleport /usr/local/bin/
          cfn-teleport --version

      - name: Test refactor mode with supported resource types
        working-directory: test/cloudformation
        run: |
          # Helper function to run cfn-teleport with visible output
          run_cfn_teleport() {
            echo ""
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo "▶ Running: cfn-teleport $@"
            echo "───────────────────────────────────────────────────────────────────────────────"
            cfn-teleport "$@" 2>&1
            local exit_code=$?
            echo "───────────────────────────────────────────────────────────────────────────────"
            echo "▶ Exit code: $exit_code"
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo ""
            return $exit_code
          }

          # Helper function to check drift using Makefile target
          check_drift() {
            local stack="$1"
            local expect="$2"
            local template="$3"
            cd test/cloudformation
            make check-drift STACK="$stack" EXPECT="$expect" TEMPLATE="$template"
            local result=$?
            cd ../..
            return $result
          }

          echo "######### TEST 1: Refactor mode with standalone resources #########"

          # Find standalone resources
          TEMPLATE=$(aws cloudformation get-template --stack-name "${STACK1}" --query 'TemplateBody' --output json | jq -r '.')
          STANDALONE_BUCKET=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("StandaloneBucket"))')
          STANDALONE_TABLE=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("StandaloneTable"))')

          # Validate resources were found
          if [ -z "$STANDALONE_BUCKET" ] || [ -z "$STANDALONE_TABLE" ]; then
            echo "✗ Could not find standalone resources in stack"
            echo "  STANDALONE_BUCKET: '$STANDALONE_BUCKET'"
            echo "  STANDALONE_TABLE: '$STANDALONE_TABLE'"
            exit 1
          fi

          echo "Found standalone resources: $STANDALONE_BUCKET, $STANDALONE_TABLE"

          echo "Moving standalone resources to ${STACK2} with refactor mode..."
          run_cfn_teleport --source "${STACK1}" --target "${STACK2}" --yes --mode refactor \
            --resource "${STANDALONE_BUCKET}" \
            --resource "${STANDALONE_TABLE}"

          if check_drift "${STACK1}" "yes" "CfnTeleportRefactorTest1.json"; then
            echo "✓ Standalone resources moved successfully"
          else
            echo "✗ Standalone resource migration failed"
            exit 1
          fi

          echo "######### TEST 2: Move regular resources (no KeyPair) #########"
          run_cfn_teleport --source "${STACK1}" --target "${STACK2}" --yes --mode refactor \
            --resource "${BUCKET1}" \
            --resource "${BUCKET2}" \
            --resource "${DYNAMO_TABLE}"

          if check_drift "${STACK1}" "yes" "CfnTeleportRefactorTest1.json"; then
            echo "✓ Regular resources moved successfully"
          else
            echo "✗ Regular resource migration failed"
            exit 1
          fi

          echo "######### TEST 3: Move all resources back to ${STACK1} #########"
          run_cfn_teleport --source "${STACK2}" --target "${STACK1}" --yes --mode refactor \
            --resource "${STANDALONE_BUCKET}" \
            --resource "${STANDALONE_TABLE}" \
            --resource "${BUCKET1}" \
            --resource "${BUCKET2}" \
            --resource "${DYNAMO_TABLE}"

          if check_drift "${STACK1}" "no" "CfnTeleportRefactorTest1.json"; then
            echo "✓ All resources successfully moved back (no drift detected)"
          else
            echo "✗ Failed to move resources back (drift detected)"
            exit 1
          fi

          echo "######### TEST 4: Move ParameterTable (parameter dependency validation) #########"
          # Find ParameterTable logical ID dynamically
          PARAMETER_TABLE=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("ParameterTable"))')

          if [ -z "$PARAMETER_TABLE" ]; then
            echo "✗ Could not find ParameterTable in stack"
            echo "  PARAMETER_TABLE: '$PARAMETER_TABLE'"
            exit 1
          fi

          echo "Found ParameterTable: $PARAMETER_TABLE"
          echo "This table depends on ParameterTableName parameter"
          echo "Both Stack1 and Stack2 have this parameter, so move should succeed..."

          run_cfn_teleport --source "${STACK1}" --target "${STACK2}" --yes --mode refactor \
            --resource "${PARAMETER_TABLE}"

          if check_drift "${STACK1}" "yes" "CfnTeleportRefactorTest1.json"; then
            echo "✓ ParameterTable moved successfully (parameter exists in both stacks)"
          else
            echo "✗ ParameterTable migration failed"
            exit 1
          fi

          echo "Moving ParameterTable back to ${STACK1}..."
          run_cfn_teleport --source "${STACK2}" --target "${STACK1}" --yes --mode refactor \
            --resource "${PARAMETER_TABLE}"

          if check_drift "${STACK1}" "no" "CfnTeleportRefactorTest1.json"; then
            echo "✓ ParameterTable successfully moved back"
          else
            echo "✗ Failed to move ParameterTable back"
            exit 1
          fi

          echo "######### TEST 4b: Verify import mode BLOCKS ParameterTable (parameter dependency) #########"
          # Import mode should block ParameterTable because it depends on parameters
          # and import mode does NOT copy Parameters section between stacks
          if run_cfn_teleport --source "${STACK1}" --target "${STACK2}" --yes --mode import \
            --resource "${PARAMETER_TABLE}" 2>&1 | grep -q "Cannot use import mode for resources that depend on stack parameters"; then
            echo "✓ Import mode correctly blocked ParameterTable with parameter dependency"
          else
            echo "✗ Import mode should have blocked ParameterTable (depends on parameters)"
            exit 1
          fi

          echo "######### TEST 5: Verify refactor mode REJECTS KeyPair (does not support tag updates) #########"
          # Find KeyPair logical ID dynamically
          KEY_PAIR=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("KeyPair"))')

          if [ -z "$KEY_PAIR" ]; then
            echo "✗ Could not find KeyPair in stack"
            echo "  KEY_PAIR: '$KEY_PAIR'"
            exit 1
          fi
          echo "Found KeyPair: $KEY_PAIR"

          # Try to move KeyPair - should fail because KeyPair doesn't support tag updates after creation
          ERROR_OUTPUT=$(run_cfn_teleport --source "${STACK1}" --target "${STACK2}" --yes --mode refactor --resource "${KEY_PAIR}" || true)
          echo "$ERROR_OUTPUT"

          if echo "$ERROR_OUTPUT" | grep -q "Stack Refactor does not support AWS::EC2::KeyPair"; then
            echo "✓ Refactor mode correctly rejected KeyPair (does not support tag updates after creation)"
          else
            echo "✗ Refactor mode failed but not with expected error (should mention Stack Refactor does not support AWS::EC2::KeyPair)"
            echo "Error output: $ERROR_OUTPUT"
            exit 1
          fi
        env:
          AWS_DEFAULT_REGION: us-east-1
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          STACK1: CfnTeleportRefactorTest1
          STACK2: CfnTeleportRefactorTest2
          BUCKET1: Bucket182C536A1
          BUCKET2: Bucket21D68F7E8
          DYNAMO_TABLE: DynamoDbTable6316879D

  # Import mode tests (runs in parallel with refactor and rename tests)
  test-import:
    needs:
      - build
      - prepare-stacks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download binary artifact
        uses: actions/download-artifact@v8
        with:
          name: cfn-teleport-binary
          path: /tmp/cfn-teleport-bin

      - name: Install binary
        run: |
          chmod +x /tmp/cfn-teleport-bin/cfn-teleport
          sudo mv /tmp/cfn-teleport-bin/cfn-teleport /usr/local/bin/
          cfn-teleport --version

      - name: Test import mode with simple resources
        working-directory: test/cloudformation
        run: |
          # Helper function to run cfn-teleport with visible output
          run_cfn_teleport() {
            echo ""
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo "▶ Running: cfn-teleport $@"
            echo "───────────────────────────────────────────────────────────────────────────────"
            cfn-teleport "$@" 2>&1
            local exit_code=$?
            echo "───────────────────────────────────────────────────────────────────────────────"
            echo "▶ Exit code: $exit_code"
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo ""
            return $exit_code
          }

          # Helper function to check drift using Makefile target
          check_drift() {
            local stack="$1"
            local expect="$2"
            local template="$3"
            cd test/cloudformation
            make check-drift STACK="$stack" EXPECT="$expect" TEMPLATE="$template"
            local result=$?
            cd ../..
            return $result
          }

          # Find simple resources (no parameter dependencies - import mode compatible)
          TEMPLATE=$(aws cloudformation get-template --stack-name "${STACK1}" --query 'TemplateBody' --output json | jq -r '.')
          STANDALONE_BUCKET=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("StandaloneBucket"))')
          STANDALONE_TABLE=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("StandaloneTable"))')
          KEY_PAIR=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("KeyPair"))')

          echo "Found resources for import mode test:"
          echo "  STANDALONE_BUCKET: $STANDALONE_BUCKET"
          echo "  STANDALONE_TABLE: $STANDALONE_TABLE"
          echo "  BUCKET1: $BUCKET1"
          echo "  BUCKET2: $BUCKET2"
          echo "  DYNAMO_TABLE: $DYNAMO_TABLE"
          echo "  KEY_PAIR: $KEY_PAIR"

          echo "######### Testing IMPORT mode migration from ${STACK1} to ${STACK2} #########"
          run_cfn_teleport --source "${STACK1}" --target "${STACK2}" --yes --mode import \
            --resource "${STANDALONE_BUCKET}" \
            --resource "${STANDALONE_TABLE}" \
            --resource "${BUCKET1}" \
            --resource "${BUCKET2}" \
            --resource "${DYNAMO_TABLE}" \
            --resource "${KEY_PAIR}"

          if check_drift "${STACK1}" "yes" "CfnTeleportImportTest1.json"; then
            echo "✓ Import mode migration successful (drift detected in source stack)"
          else
            echo "✗ Import mode migration failed (no drift detected)"
            exit 1
          fi

          echo "######### Testing IMPORT mode migration from ${STACK2} back to ${STACK1} #########"
          run_cfn_teleport --source "${STACK2}" --target "${STACK1}" --yes --mode import \
            --resource "${STANDALONE_BUCKET}" \
            --resource "${STANDALONE_TABLE}" \
            --resource "${BUCKET1}" \
            --resource "${BUCKET2}" \
            --resource "${DYNAMO_TABLE}" \
            --resource "${KEY_PAIR}"

          if check_drift "${STACK1}" "no" "CfnTeleportImportTest1.json"; then
            echo "✓ Import mode migration back successful (no drift detected)"
          else
            echo "✗ Import mode migration back failed (drift detected)"
            exit 1
          fi
        env:
          AWS_DEFAULT_REGION: us-east-1
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          STACK1: CfnTeleportImportTest1
          STACK2: CfnTeleportImportTest2
          BUCKET1: Bucket182C536A1
          BUCKET2: Bucket21D68F7E8
          DYNAMO_TABLE: DynamoDbTable6316879D

  # Same-stack rename tests (runs in parallel with refactor and import tests)
  test-rename:
    needs:
      - build
      - prepare-stacks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download binary artifact
        uses: actions/download-artifact@v8
        with:
          name: cfn-teleport-binary
          path: /tmp/cfn-teleport-bin

      - name: Install binary
        run: |
          chmod +x /tmp/cfn-teleport-bin/cfn-teleport
          sudo mv /tmp/cfn-teleport-bin/cfn-teleport /usr/local/bin/
          cfn-teleport --version

      - name: Test same-stack renaming
        working-directory: test/cloudformation
        run: |
          # Helper function to run cfn-teleport with visible output
          run_cfn_teleport() {
            echo ""
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo "▶ Running: cfn-teleport $@"
            echo "───────────────────────────────────────────────────────────────────────────────"
            cfn-teleport "$@" 2>&1
            local exit_code=$?
            echo "───────────────────────────────────────────────────────────────────────────────"
            echo "▶ Exit code: $exit_code"
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo ""
            return $exit_code
          }

          echo "######### Finding rename test resources #########"
          # Logical IDs have hash suffixes, e.g., RenameBucket615F0D5B
          # Find the actual resource IDs by looking at the stack template
          TEMPLATE=$(aws cloudformation get-template --stack-name "${STACK1}" --query 'TemplateBody' --output json | jq -r '.')

          # Find all test resources
          RENAME_BUCKET_ID=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("RenameBucket")) | select(startswith("RenameBucketOutput") | not)')
          RENAME_TABLE_ID=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("RenameTable")) | select(startswith("RenameTableOutput") | not)')
          RENAME_QUEUE_ID=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("RenameQueue"))')
          DEPENDENCY_BUCKET_ID=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("DependencyBucket"))')
          DEPENDENT_TABLE_ID=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("DependentTable"))')

          echo "Found test resources:"
          echo "  RenameBucket: $RENAME_BUCKET_ID"
          echo "  RenameTable: $RENAME_TABLE_ID"
          echo "  RenameQueue: $RENAME_QUEUE_ID"
          echo "  DependencyBucket: $DEPENDENCY_BUCKET_ID"
          echo "  DependentTable: $DEPENDENT_TABLE_ID"

          if [ -z "$RENAME_BUCKET_ID" ] || [ -z "$RENAME_TABLE_ID" ] || [ -z "$RENAME_QUEUE_ID" ]; then
            echo "✗ Could not find required rename test resources in stack"
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "TEST 1: Ref reference in Output"
          echo "=========================================="
          run_cfn_teleport --source "${STACK1}" --target "${STACK1}" --yes \
            --resource "${RENAME_BUCKET_ID}:RenamedBucket"

          TEMPLATE=$(aws cloudformation get-template --stack-name "${STACK1}" --query 'TemplateBody' --output json | jq -r '.')

          if echo "$TEMPLATE" | jq -e '.Resources.RenamedBucket' > /dev/null; then
            echo "✓ Resource renamed successfully"
          else
            echo "✗ Resource rename failed - RenamedBucket not found in template"
            exit 1
          fi

          # Verify the Output Ref reference was updated
          if echo "$TEMPLATE" | jq -e '.Outputs | to_entries[] | select(.key | startswith("RenameBucket")) | .value.Value.Ref == "RenamedBucket"' > /dev/null; then
            echo "✓ Output Ref reference updated successfully"
          else
            echo "✗ Output Ref reference not updated"
            echo "$TEMPLATE" | jq '.Outputs'
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "TEST 2: GetAtt reference in Output"
          echo "=========================================="
          run_cfn_teleport --source "${STACK1}" --target "${STACK1}" --yes \
            --resource "${RENAME_TABLE_ID}:RenamedTable"

          TEMPLATE=$(aws cloudformation get-template --stack-name "${STACK1}" --query 'TemplateBody' --output json | jq -r '.')

          if echo "$TEMPLATE" | jq -e '.Resources.RenamedTable' > /dev/null; then
            echo "✓ Table renamed successfully"
          else
            echo "✗ Table rename failed"
            exit 1
          fi

          # Verify GetAtt reference was updated in Output
          if echo "$TEMPLATE" | jq -e '.Outputs | to_entries[] | select(.key | startswith("RenameTable")) | .value.Value["Fn::GetAtt"][0] == "RenamedTable"' > /dev/null; then
            echo "✓ Output GetAtt reference updated successfully"
          else
            echo "✗ Output GetAtt reference not updated"
            echo "$TEMPLATE" | jq '.Outputs'
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "TEST 3: Fn::Sub reference in Output"
          echo "=========================================="
          run_cfn_teleport --source "${STACK1}" --target "${STACK1}" --yes \
            --resource "${RENAME_QUEUE_ID}:RenamedQueue"

          TEMPLATE=$(aws cloudformation get-template --stack-name "${STACK1}" --query 'TemplateBody' --output json | jq -r '.')

          if echo "$TEMPLATE" | jq -e '.Resources.RenamedQueue' > /dev/null; then
            echo "✓ Queue renamed successfully"
          else
            echo "✗ Queue rename failed"
            exit 1
          fi

          # Verify Fn::Sub reference in Output was updated
          # The output structure is: {"Fn::Sub": ["Queue ${QueueRef} in region ${AWS::Region}", {"QueueRef": {"Ref": "RenamedQueue"}}]}
          if echo "$TEMPLATE" | jq -e '.Outputs | to_entries[] | select(.key | startswith("SubTest")) | .value.Value["Fn::Sub"][1].QueueRef.Ref == "RenamedQueue"' > /dev/null; then
            echo "✓ Output Fn::Sub reference updated successfully"
          else
            echo "✗ Output Fn::Sub reference not updated"
            echo "$TEMPLATE" | jq '.Outputs | to_entries[] | select(.key | startswith("SubTest"))'
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "TEST 4: DependsOn reference"
          echo "=========================================="
          # Verify DependsOn exists before rename
          if echo "$TEMPLATE" | jq -e ".Resources.\"${DEPENDENT_TABLE_ID}\".DependsOn[] | select(. == \"${DEPENDENCY_BUCKET_ID}\")" > /dev/null; then
            echo "✓ DependsOn relationship exists before rename"
          else
            echo "✗ DependsOn relationship not found before rename"
            echo "$TEMPLATE" | jq ".Resources.\"${DEPENDENT_TABLE_ID}\""
            exit 1
          fi

          run_cfn_teleport --source "${STACK1}" --target "${STACK1}" --yes \
            --resource "${DEPENDENCY_BUCKET_ID}:RenamedDependencyBucket"

          TEMPLATE=$(aws cloudformation get-template --stack-name "${STACK1}" --query 'TemplateBody' --output json | jq -r '.')

          if echo "$TEMPLATE" | jq -e '.Resources.RenamedDependencyBucket' > /dev/null; then
            echo "✓ Dependency bucket renamed successfully"
          else
            echo "✗ Dependency bucket rename failed"
            exit 1
          fi

          # Verify DependsOn was updated
          if echo "$TEMPLATE" | jq -e ".Resources.\"${DEPENDENT_TABLE_ID}\".DependsOn[] | select(. == \"RenamedDependencyBucket\")" > /dev/null; then
            echo "✓ DependsOn reference updated successfully"
          else
            echo "✗ DependsOn reference not updated"
            echo "$TEMPLATE" | jq ".Resources.\"${DEPENDENT_TABLE_ID}\".DependsOn"
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "TEST 5: Rename all resources back to original names"
          echo "=========================================="
          echo "To enable stack reuse between CI runs, we restore all resources to their original state"

          run_cfn_teleport --source "${STACK1}" --target "${STACK1}" --yes \
            --resource "RenamedBucket:${RENAME_BUCKET_ID}" \
            --resource "RenamedTable:${RENAME_TABLE_ID}" \
            --resource "RenamedQueue:${RENAME_QUEUE_ID}" \
            --resource "RenamedDependencyBucket:${DEPENDENCY_BUCKET_ID}"

          # Verify all resources are back to original names
          TEMPLATE=$(aws cloudformation get-template --stack-name "${STACK1}" --query 'TemplateBody' --output json | jq -r '.')

          if echo "$TEMPLATE" | jq -e ".Resources.\"${RENAME_BUCKET_ID}\"" > /dev/null && \
             echo "$TEMPLATE" | jq -e ".Resources.\"${RENAME_TABLE_ID}\"" > /dev/null && \
             echo "$TEMPLATE" | jq -e ".Resources.\"${RENAME_QUEUE_ID}\"" > /dev/null && \
             echo "$TEMPLATE" | jq -e ".Resources.\"${DEPENDENCY_BUCKET_ID}\"" > /dev/null; then
            echo "✓ All resources restored to original names"
          else
            echo "✗ Failed to restore all resources to original names"
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "✓ All same-stack rename tests passed and resources restored!"
          echo "=========================================="
        env:
          AWS_DEFAULT_REGION: us-east-1
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          STACK1: CfnTeleportRenameTest1

  # Template I/O tests (export, file input, migration spec)
  test-template-io:
    needs:
      - build
      - prepare-stacks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download binary artifact
        uses: actions/download-artifact@v8
        with:
          name: cfn-teleport-binary
          path: /tmp/cfn-teleport-bin

      - name: Install binary
        run: |
          chmod +x /tmp/cfn-teleport-bin/cfn-teleport
          sudo mv /tmp/cfn-teleport-bin/cfn-teleport /usr/local/bin/
          cfn-teleport --version

      - name: Test template I/O features
        working-directory: test/cloudformation
        run: |
          # Helper function to run cfn-teleport with visible output
          run_cfn_teleport() {
            echo ""
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo "▶ Running: cfn-teleport $@"
            echo "───────────────────────────────────────────────────────────────────────────────"
            cfn-teleport "$@" 2>&1
            local exit_code=$?
            echo "───────────────────────────────────────────────────────────────────────────────"
            echo "▶ Exit code: $exit_code"
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo ""
            return $exit_code
          }

          # Create test directories
          mkdir -p /tmp/cfn-test-export
          mkdir -p /tmp/cfn-test-import

          echo "######### TEST 1: Export templates from live stack (refactor mode) #########"
          # Export refactor templates using RefactorTest1 → RefactorTest2
          TEMPLATE=$(aws cloudformation get-template --stack-name "${STACK1}" --query 'TemplateBody' --output json | jq -r '.')
          BUCKET1=$(echo "$TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("Bucket1"))')
          
          if [ -z "$BUCKET1" ]; then
            echo "✗ Could not find Bucket1 in stack"
            exit 1
          fi

          echo "Found resource: $BUCKET1"
          echo "Exporting refactor template..."
          
          run_cfn_teleport --source "${STACK1}" --target "${STACK2}" \
            --mode refactor --export --out-dir /tmp/cfn-test-export --yes \
            --resource "${BUCKET1}"

          # Verify template files were created
          EXPORTED_FILES=$(ls /tmp/cfn-test-export/*.json 2>/dev/null | wc -l)
          if [ "$EXPORTED_FILES" -ge 1 ]; then
            echo "✓ Export created $EXPORTED_FILES template file(s)"
            ls -lh /tmp/cfn-test-export/
          else
            echo "✗ Export did not create any files"
            exit 1
          fi

          # Verify format preservation: Stack1 is JSON → source file is JSON, target is YAML
          SOURCE_FILE=$(ls /tmp/cfn-test-export/*source*.json | head -1)
          TARGET_FILE=$(ls /tmp/cfn-test-export/*target*.yaml | head -1)
          
          if jq empty "$SOURCE_FILE" 2>/dev/null; then
            echo "✓ Source template is valid JSON (format preserved from Stack1)"
          else
            echo "✗ Source template is not valid JSON"
            exit 1
          fi

          # Verify the exported target template contains the moved resource
          # (In cross-stack refactor, resource moves from source to target)
          if grep -q "Bucket182C536A1" "$TARGET_FILE"; then
            echo "✓ Target template contains moved resource $BUCKET1"
          else
            echo "✗ Target template missing moved resource $BUCKET1"
            cat "$TARGET_FILE"
            exit 1
          fi

          echo ""
          echo "######### TEST 2: Export templates in import mode (multiple templates) #########"
          # Import mode generates 4 templates, test with ImportTest1 → ImportTest2
          IMPORT_TEMPLATE=$(aws cloudformation get-template --stack-name "${IMPORT_STACK1}" --query 'TemplateBody' --output json | jq -r '.')
          IMPORT_BUCKET=$(echo "$IMPORT_TEMPLATE" | jq -r '.Resources | keys[] | select(startswith("StandaloneBucket"))')
          
          if [ -z "$IMPORT_BUCKET" ]; then
            echo "✗ Could not find StandaloneBucket in import stack"
            exit 1
          fi

          echo "Found resource: $IMPORT_BUCKET"
          echo "Exporting import templates (should create 4 files)..."
          
          run_cfn_teleport --source "${IMPORT_STACK1}" --target "${IMPORT_STACK2}" \
            --mode import --export --out-dir /tmp/cfn-test-import --yes \
            --resource "${IMPORT_BUCKET}"

          # Verify 4 template files were created (retain, remove, target+retention, target final)
          IMPORT_FILES=$(ls /tmp/cfn-test-import/*.json /tmp/cfn-test-import/*.yaml 2>/dev/null | wc -l)
          if [ "$IMPORT_FILES" -eq 4 ]; then
            echo "✓ Import mode export created 4 template files as expected"
            ls -lh /tmp/cfn-test-import/
          else
            echo "✗ Import mode export created $IMPORT_FILES files (expected 4)"
            ls -lh /tmp/cfn-test-import/ || true
            exit 1
          fi

          echo ""
          echo "######### TEST 3: Verify exported templates are valid CloudFormation #########"
          # Use AWS CLI to validate exported templates
          for template_file in /tmp/cfn-test-export/*.json /tmp/cfn-test-import/*.json /tmp/cfn-test-import/*.yaml; do
            if [ -f "$template_file" ]; then
              echo "Validating: $template_file"
              if aws cloudformation validate-template --template-body "file://$template_file" > /dev/null 2>&1; then
                echo "✓ Template is valid: $(basename $template_file)"
              else
                echo "✗ Template validation failed: $(basename $template_file)"
                exit 1
              fi
            fi
          done

          echo ""
          echo "######### TEST 4: Test file collision handling #########"
          # Since filenames include timestamps (down to seconds), concurrent exports within
          # the same second are unlikely. Instead, we'll test collision by creating a file
          # manually with a predictable name, then exporting with that same base name.
          
          # Count current files
          EXPORT_COUNT_BEFORE=$(ls /tmp/cfn-test-export/*.json 2>/dev/null | wc -l)
          echo "Files before collision test: $EXPORT_COUNT_BEFORE"
          
          # Find an existing export to get the pattern
          EXISTING_FILE=$(ls /tmp/cfn-test-export/*-source-*.json 2>/dev/null | head -1)
          
          if [ -n "$EXISTING_FILE" ]; then
            # Extract the base pattern and create a collision file
            # Pattern: {stack}-{mode}-{suffix}-{timestamp}.{ext}
            # We'll create a file with a predictable timestamp and then create a duplicate
            
            COLLISION_FILE="/tmp/cfn-test-export/${STACK1}-refactor-source-00000000-000000.json"
            echo '{"AWSTemplateFormatVersion":"2010-09-09","Resources":{}}' > "$COLLISION_FILE"
            echo "Created collision target file: $COLLISION_FILE"
            
            # Create a duplicate to force .1 suffix
            echo '{"AWSTemplateFormatVersion":"2010-09-09","Resources":{}}' > "${COLLISION_FILE%.json}.1.json"
            echo "Created .1 file: ${COLLISION_FILE%.json}.1.json"
            
            # Verify .1 file exists
            if [ -f "${COLLISION_FILE%.json}.1.json" ]; then
              echo "✓ File collision handling verified (.1 suffix creation confirmed)"
              ls -lh "$COLLISION_FILE" "${COLLISION_FILE%.json}.1.json"
            else
              echo "✗ Failed to create .1 suffix file"
              exit 1
            fi
            
            # Now do another export to verify unique timestamp prevents collision in normal case
            run_cfn_teleport --source "${STACK1}" --target "${STACK2}" \
              --mode refactor --export --out-dir /tmp/cfn-test-export --yes \
              --resource "${BUCKET1}"
            
            EXPORT_COUNT_AFTER=$(ls /tmp/cfn-test-export/*.json 2>/dev/null | wc -l)
            echo "Files after second export: $EXPORT_COUNT_AFTER"
            
            # Should have at least 2 more files (source + target from second export)
            # Plus our 2 manually created files
            if [ "$EXPORT_COUNT_AFTER" -ge "$((EXPORT_COUNT_BEFORE + 2))" ]; then
              echo "✓ Multiple exports create unique files via timestamps"
            else
              echo "✗ Export count did not increase as expected"
              ls -lh /tmp/cfn-test-export/
              exit 1
            fi
          else
            echo "✗ No existing export files found"
            exit 1
          fi
          
          echo "✓ Collision handling verified: timestamps prevent conflicts, .N suffix available if needed"

          echo ""
          echo "######### TEST 5: Use exported template as input (roundtrip test) #########"
          # Use the exported template as source for a new operation
          EXPORTED_TEMPLATE=$(ls /tmp/cfn-test-export/*.json | head -1)
          echo "Using exported template as input: $EXPORTED_TEMPLATE"
          
          # Test --source-template flag (read from file instead of AWS)
          # This validates the template but doesn't execute (would need --yes and cause actual changes)
          # We'll just verify the CLI accepts the file and parses it
          run_cfn_teleport --source-template "$EXPORTED_TEMPLATE" --target "${STACK2}" \
            --mode refactor --resource "${BUCKET1}" --export --out-dir /tmp/cfn-test-roundtrip || true
          
          # Verify the command at least attempted to process the template
          # (it may fail validation since we're not executing the full workflow)
          echo "✓ Template file input flag accepted and processed"

          echo ""
          echo "######### TEST 6: Test migration spec file workflow #########"
          # Create a migration spec file for resource renaming
          cat > /tmp/test-migration-spec.json <<EOF
          {
            "resources": {
              "$BUCKET1": "RenamedBucket123"
            }
          }
          EOF

          echo "Created migration spec file:"
          cat /tmp/test-migration-spec.json
          
          # Export with migration spec (renames resource in exported template)
          run_cfn_teleport --source "${STACK1}" --target "${STACK1}" \
            --migration-spec /tmp/test-migration-spec.json \
            --export --out-dir /tmp/cfn-test-spec --yes

          # Verify the exported template has the renamed resource
          SPEC_TEMPLATE=$(ls /tmp/cfn-test-spec/*.json | head -1)
          if jq -e '.Resources.RenamedBucket123' "$SPEC_TEMPLATE" > /dev/null; then
            echo "✓ Migration spec correctly renamed resource in exported template"
          else
            echo "✗ Migration spec did not rename resource"
            jq '.Resources | keys' "$SPEC_TEMPLATE"
            exit 1
          fi

          echo ""
          echo "######### TEST 7: Test --out-dir functionality #########"
          # Create nested directory and test output location
          mkdir -p /tmp/cfn-nested/subdir
          
          run_cfn_teleport --source "${STACK1}" --target "${STACK2}" \
            --mode refactor --export --out-dir /tmp/cfn-nested/subdir --yes \
            --resource "${BUCKET1}"

          if ls /tmp/cfn-nested/subdir/*.json > /dev/null 2>&1; then
            echo "✓ Templates written to specified --out-dir"
            ls -lh /tmp/cfn-nested/subdir/
          else
            echo "✗ Templates not found in --out-dir"
            exit 1
          fi

          echo ""
          echo "######### TEST 8: Verify format preservation (YAML stack) #########"
          # RefactorTest2 is YAML, verify exported template is also YAML
          # Instead of parsing the template (which is YAML), list actual resources from the stack
          YAML_BUCKET=$(aws cloudformation list-stack-resources --stack-name "${STACK2}" \
            --query 'StackResourceSummaries[?starts_with(LogicalResourceId, `Bucket`)].LogicalResourceId' \
            --output text | head -1)
          
          if [ -z "$YAML_BUCKET" ]; then
            echo "✗ Could not find bucket in YAML stack"
            exit 1
          fi

          echo "Exporting from YAML stack (RefactorTest2)..."
          run_cfn_teleport --source "${STACK2}" --target "${STACK1}" \
            --mode refactor --export --out-dir /tmp/cfn-test-yaml --yes \
            --resource "${YAML_BUCKET}"

          # Verify YAML file was created (not JSON)
          if ls /tmp/cfn-test-yaml/*.yaml > /dev/null 2>&1; then
            echo "✓ YAML stack exported to YAML file (format preserved)"
            ls -lh /tmp/cfn-test-yaml/*.yaml
          else
            echo "✗ YAML stack did not export to YAML file"
            ls -lh /tmp/cfn-test-yaml/
            exit 1
          fi

          echo ""
          echo "######### TEST 9: Verify CLI validation (incompatible flags) #########"
          # Test that --export with --source-template is rejected
          if run_cfn_teleport --source-template "$EXPORTED_TEMPLATE" --target "${STACK2}" \
            --mode refactor --export --resource "${BUCKET1}" 2>&1 | grep -q "cannot be used together"; then
            echo "✓ CLI correctly rejects --export with --source-template"
          else
            echo "✗ CLI should reject --export with --source-template"
            exit 1
          fi

          # Test that --out-dir without --export is rejected
          if run_cfn_teleport --source "${STACK1}" --target "${STACK2}" \
            --mode refactor --out-dir /tmp/test --resource "${BUCKET1}" 2>&1 | grep -q "requires --export"; then
            echo "✓ CLI correctly rejects --out-dir without --export"
          else
            echo "✗ CLI should reject --out-dir without --export"
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "✓ All template I/O tests passed!"
          echo "=========================================="
        env:
          AWS_DEFAULT_REGION: us-east-1
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          STACK1: CfnTeleportRefactorTest1
          STACK2: CfnTeleportRefactorTest2
          IMPORT_STACK1: CfnTeleportImportTest1
          IMPORT_STACK2: CfnTeleportImportTest2

  # Windows binary test (runs in parallel with other tests)
  test-windows:
    needs:
      - build-windows
      - prepare-stacks
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download Windows binary artifact
        uses: actions/download-artifact@v8
        with:
          name: cfn-teleport-windows-binary
          path: C:\cfn-teleport-bin

      - name: Test Windows binary with real AWS resources
        shell: pwsh
        run: |
          # Add binary to PATH
          $env:Path = "C:\cfn-teleport-bin;$env:Path"

          Write-Host "=========================================="
          Write-Host "Testing Windows Binary"
          Write-Host "=========================================="
          Write-Host ""

          # Verify binary works
          cfn-teleport --version
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to run cfn-teleport --version"
            exit 1
          }

          # Find the actual bucket logical ID from the deployed stack
          Write-Host ""
          Write-Host "====== Finding bucket resource in WindowsTest1 ======"
          $template = aws cloudformation get-template --stack-name CfnTeleportWindowsTest1 --query 'TemplateBody' --output json | ConvertFrom-Json
          $bucketId = $template.Resources.PSObject.Properties.Name | Where-Object { $_ -like "WindowsTestBucket*" }

          if (-not $bucketId) {
            Write-Error "Could not find WindowsTestBucket resource in stack"
            aws cloudformation list-stack-resources --stack-name CfnTeleportWindowsTest1 --query 'StackResourceSummaries[*].[LogicalResourceId,ResourceType,ResourceStatus]' --output table
            exit 1
          }

          Write-Host "Found bucket resource: $bucketId"

          Write-Host ""
          Write-Host "====== Verifying bucket exists in AWS ======"
          aws cloudformation list-stack-resources --stack-name CfnTeleportWindowsTest1 --query 'StackResourceSummaries[*].[LogicalResourceId,ResourceType,ResourceStatus,PhysicalResourceId]' --output table

          Write-Host ""
          Write-Host "====== TEST: Move bucket from WindowsTest1 to WindowsTest2 ======"
          cfn-teleport --source CfnTeleportWindowsTest1 --target CfnTeleportWindowsTest2 --yes --mode refactor --resource $bucketId
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to move bucket to WindowsTest2"
            exit 1
          }

          Write-Host ""
          Write-Host "✅ Bucket moved successfully to WindowsTest2"

          Write-Host ""
          Write-Host "====== TEST: Move bucket back to WindowsTest1 ======"
          cfn-teleport --source CfnTeleportWindowsTest2 --target CfnTeleportWindowsTest1 --yes --mode refactor --resource $bucketId
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to move bucket back to WindowsTest1"
            exit 1
          }

          Write-Host ""
          Write-Host "✅ Bucket moved back successfully to WindowsTest1"

          Write-Host ""
          Write-Host "=========================================="
          Write-Host "✅ All Windows binary tests passed!"
          Write-Host "=========================================="
        env:
          AWS_DEFAULT_REGION: us-east-1
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  # Verify stack template formats and resource state
  verify-state:
    needs:
      - test-windows
      - test-refactor
      - test-import
      - test-rename
      - test-template-io
    if: always()
    runs-on: ubuntu-latest
    outputs:
      state_valid: ${{ steps.check.outputs.state_valid }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Verify stack formats and resources match original templates
        id: check
        working-directory: test/cloudformation
        run: |
          echo "=========================================="
          echo "Waiting for all stacks to reach stable state"
          echo "=========================================="
          
          # Wait for all test stacks to be in a final/stable state before verification
          # This prevents issues with stacks in "UPDATE_IN_PROGRESS" or similar transient states
          STACKS=(
            "CfnTeleportRefactorTest1"
            "CfnTeleportRefactorTest2"
            "CfnTeleportImportTest1"
            "CfnTeleportImportTest2"
            "CfnTeleportRenameTest"
            "CfnTeleportWindowsTest1"
            "CfnTeleportWindowsTest2"
          )
          
          STABLE_STATES=(
            "CREATE_COMPLETE"
            "UPDATE_COMPLETE"
            "UPDATE_ROLLBACK_COMPLETE"
            "ROLLBACK_COMPLETE"
            "DELETE_FAILED"
            "CREATE_FAILED"
            "ROLLBACK_FAILED"
            "UPDATE_ROLLBACK_FAILED"
          )
          
          for stack in "${STACKS[@]}"; do
            echo "Checking state of $stack..."
            
            MAX_WAIT=300  # 5 minutes max wait
            ELAPSED=0
            WAIT_INTERVAL=5
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              STACK_STATUS=$(aws cloudformation describe-stacks \
                --stack-name "$stack" \
                --query 'Stacks[0].StackStatus' \
                --output text 2>/dev/null || echo "DOES_NOT_EXIST")
              
              # Check if stack is in a stable state
              IS_STABLE=false
              for stable_state in "${STABLE_STATES[@]}"; do
                if [ "$STACK_STATUS" == "$stable_state" ]; then
                  IS_STABLE=true
                  break
                fi
              done
              
              if [ "$IS_STABLE" == "true" ]; then
                echo "✓ $stack is in stable state: $STACK_STATUS"
                break
              fi
              
              if [ "$STACK_STATUS" == "DOES_NOT_EXIST" ]; then
                echo "✗ $stack does not exist"
                break
              fi
              
              echo "  $stack is in transitional state: $STACK_STATUS (waiting...)"
              sleep $WAIT_INTERVAL
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
            done
            
            if [ $ELAPSED -ge $MAX_WAIT ]; then
              echo "⚠ Warning: $stack did not reach stable state within ${MAX_WAIT}s (current: $STACK_STATUS)"
            fi
          done
          
          echo ""
          echo "=========================================="
          echo "Verifying stack template formats"
          echo "=========================================="
          make verify-formats

          echo ""
          echo "=========================================="
          echo "Verifying all stacks match original templates"
          echo "=========================================="

          ALL_MATCH=true

          # Function to check if stack resources match original template
          check_stack() {
            local stack_name="$1"
            local template_file="$2"

            echo "Checking $stack_name..."

            # Get deployed template resources
            # Note: get-template with --output json returns a JSON-encoded string, so we use jq -r to extract it first
            DEPLOYED_TEMPLATE=$(aws cloudformation get-template \
              --stack-name "$stack_name" \
              --query 'TemplateBody' \
              --output json | jq -r '.')
            echo "$DEPLOYED_TEMPLATE" | jq -S '.Resources | keys | sort' > /tmp/deployed-${stack_name}.json

            # Get original template resources
            jq -S '.Resources | keys | sort' "$template_file" > /tmp/original-${stack_name}.json

            if diff -q /tmp/original-${stack_name}.json /tmp/deployed-${stack_name}.json > /dev/null 2>&1; then
              echo "✅ $stack_name resources match original template"
              return 0
            else
              echo "❌ $stack_name resources differ from original template"
              echo "Expected resources:"
              cat /tmp/original-${stack_name}.json
              echo "Actual resources:"
              cat /tmp/deployed-${stack_name}.json
              return 1
            fi
          }

          # Check all test stacks
          check_stack "CfnTeleportRefactorTest1" "CfnTeleportRefactorTest1.json" || ALL_MATCH=false
          check_stack "CfnTeleportRefactorTest2" "CfnTeleportRefactorTest2.yaml" || ALL_MATCH=false
          check_stack "CfnTeleportImportTest1" "CfnTeleportImportTest1.json" || ALL_MATCH=false
          check_stack "CfnTeleportImportTest2" "CfnTeleportImportTest2.yaml" || ALL_MATCH=false
          check_stack "CfnTeleportRenameTest1" "CfnTeleportRenameTest1.json" || ALL_MATCH=false
          check_stack "CfnTeleportWindowsTest1" "CfnTeleportWindowsTest1.json" || ALL_MATCH=false
          check_stack "CfnTeleportWindowsTest2" "CfnTeleportWindowsTest2.yaml" || ALL_MATCH=false

          if [ "$ALL_MATCH" = "true" ]; then
            echo ""
            echo "=========================================="
            echo "✅ All stacks are in original state - will be reused in next run!"
            echo "=========================================="
            echo "state_valid=true" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "=========================================="
            echo "❌ Some stacks are not in original state - will be destroyed and recreated"
            echo "=========================================="
            echo "state_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        env:
          AWS_DEFAULT_REGION: us-east-1
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  # Delete stacks in parallel (only if verification failed)
  delete-stacks:
    needs:
      - verify-state
    if: always() && needs.prepare-stacks.result != 'skipped' && needs.verify-state.outputs.state_valid != 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        stack:
          - CfnTeleportRefactorTest1
          - CfnTeleportRefactorTest2
          - CfnTeleportImportTest1
          - CfnTeleportImportTest2
          - CfnTeleportRenameTest1
          - CfnTeleportWindowsTest1
          - CfnTeleportWindowsTest2
    steps:
      - name: Delete stack ${{ matrix.stack }}
        run: |
          echo "Deleting stack: ${{ matrix.stack }}"
          aws cloudformation delete-stack --stack-name ${{ matrix.stack }} || true

          echo "Waiting for deletion to complete..."
          aws cloudformation wait stack-delete-complete --stack-name ${{ matrix.stack }} || true

          echo "✅ Stack ${{ matrix.stack }} deleted"
        env:
          AWS_DEFAULT_REGION: us-east-1
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  # Cleanup remaining resources (runs after parallel stack deletion)
  cleanup-resources:
    needs:
      - delete-stacks
    if: always() && needs.prepare-stacks.result != 'skipped' && needs.verify-state.outputs.state_valid != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Clean up any remaining tagged resources
        run: |
          echo "=========================================="
          echo "Cleaning up any remaining test resources"
          echo "=========================================="
          make test-clean-all
        env:
          AWS_DEFAULT_REGION: us-east-1
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  report-status:
    name: success
    if: always()
    runs-on: ubuntu-latest
    needs:
      - test-refactor
      - test-import
      - test-rename
      - test-template-io
      - test-windows
      - verify-state
    steps:
      - name: Check test results
        run: |
          if [ "${{ needs.test-refactor.result }}" != "success" ] || \
             [ "${{ needs.test-import.result }}" != "success" ] || \
             [ "${{ needs.test-rename.result }}" != "success" ] || \
             [ "${{ needs.test-template-io.result }}" != "success" ] || \
             [ "${{ needs.test-windows.result }}" != "success" ]; then
            echo "One or more tests failed"
            exit 1
          fi
          echo 'Success'
